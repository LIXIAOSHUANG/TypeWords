{"version":3,"file":"event-qcx2F2JA.js","sources":["../../../../app/hooks/event.ts"],"sourcesContent":["import { onDeactivated, onMounted, onUnmounted, watch } from 'vue'\nimport { emitter, EventKey } from '@/utils/eventBus.ts'\nimport { useRuntimeStore } from '@/stores/runtime.ts'\nimport { useSettingStore } from '@/stores/setting.ts'\nimport { isMobile } from '@/utils'\n\nexport function useWindowClick(cb: (e: PointerEvent) => void) {\n  const add = () => {\n    emitter.on(EventKey.closeOther, cb)\n    window.addEventListener('click', cb)\n  }\n  onMounted(add)\n  // onActivated(add)\n\n  const remove = () => {\n    window.removeEventListener('click', cb)\n  }\n  onUnmounted(remove)\n  onDeactivated(remove)\n}\n\nexport function useEventListener(type: string, listener: EventListenerOrEventListenerObject) {\n  const invokeListener = (event: KeyboardEvent) => {\n    if (typeof listener === 'function') {\n      return (listener as EventListener)(event)\n    }\n    if (listener && typeof (listener as EventListenerObject).handleEvent === 'function') {\n      return (listener as EventListenerObject).handleEvent(event)\n    }\n  }\n\n  let cleanup: (() => void) | null = null\n\n  const add = () => {\n    const cleanupFns: Array<() => void> = []\n    const registerCleanup = (fn: () => void) => cleanupFns.push(fn)\n\n    const performCleanup = () => {\n      while (cleanupFns.length) {\n        const fn = cleanupFns.pop()\n        try {\n          fn()\n        } catch (err) {\n          console.warn('[useEventListener] cleanup error', err)\n        }\n      }\n    }\n\n    if (isMobile() && type === 'keydown') {\n      const ensureMobileInput = () => {\n        let input = document.querySelector('#typing-listener') as HTMLInputElement | null\n        if (!input) {\n          input = document.createElement('input')\n          input.id = 'typing-listener'\n          input.type = 'text'\n          input.autocomplete = 'off'\n          input.autocapitalize = 'off'\n          input.autocorrect = false\n          input.spellcheck = false\n          input.tabIndex = -1\n          input.setAttribute('aria-hidden', 'true')\n          Object.assign(input.style, {\n            position: 'fixed',\n            opacity: '0',\n            pointerEvents: 'none',\n            width: '1px',\n            height: '1px',\n            top: '0',\n            left: '-9999px',\n            zIndex: '-1',\n          })\n        }\n        if (!input.parentNode) {\n          document.body.appendChild(input)\n        }\n        return input\n      }\n\n      const hiddenInput = ensureMobileInput()\n      let isComposing = false\n      const ignoredKeys = new Set<string>()\n      const markIgnore = (key: string) => {\n        ignoredKeys.add(key)\n        window.setTimeout(() => ignoredKeys.delete(key), 150)\n      }\n\n      const createSyntheticEvent = (payload: { key: string; code?: string; keyCode: number }) => {\n        const base = {\n          key: payload.key,\n          code: payload.code ?? '',\n          keyCode: payload.keyCode,\n          which: payload.keyCode,\n          ctrlKey: false,\n          altKey: false,\n          shiftKey: false,\n          metaKey: false,\n          repeat: false,\n          isComposing: false,\n          type,\n          preventDefault() {},\n          stopPropagation() {},\n          stopImmediatePropagation() {},\n        }\n        return base as unknown as KeyboardEvent\n      }\n\n      const dispatchSyntheticKey = (payload: { key: string; code?: string; keyCode: number }) => {\n        markIgnore(payload.key)\n        invokeListener(createSyntheticEvent(payload))\n      }\n\n      const handleCompositionStart = () => {\n        isComposing = true\n      }\n\n      const handleCompositionEnd = (event: CompositionEvent) => {\n        isComposing = false\n        if (!event.data) {\n          hiddenInput.value = ''\n          return\n        }\n        for (const char of event.data) {\n          const keyCode = char === ' ' ? 32 : char.toUpperCase().charCodeAt(0)\n          dispatchSyntheticKey({\n            key: char,\n            code: char === ' ' ? 'Space' : undefined,\n            keyCode,\n          })\n        }\n        hiddenInput.value = ''\n      }\n\n      const handleInput = (event: InputEvent) => {\n        if (isComposing) return\n        const target = event.target as HTMLInputElement | null\n        const value = target?.value ?? ''\n\n        if (event.inputType === 'deleteContentBackward') {\n          dispatchSyntheticKey({ key: 'Backspace', code: 'Backspace', keyCode: 8 })\n          if (target) target.value = ''\n          return\n        }\n\n        const char = value.slice(-1) || (event as any).data?.slice(-1)\n        if (!char) {\n          if (target) target.value = ''\n          return\n        }\n\n        const keyCode = char === ' ' ? 32 : char.toUpperCase().charCodeAt(0)\n        dispatchSyntheticKey({\n          key: char,\n          code: char === ' ' ? 'Space' : undefined,\n          keyCode,\n        })\n\n        window.setTimeout(() => {\n          if (target) target.value = ''\n        }, 0)\n      }\n\n      const shouldFocusInput = (target: HTMLElement | null) => {\n        if (!target) return false\n        if (!window.location.pathname.includes('/practice')) return false\n        const typingWord = target.closest('.typing-word')\n        if (!typingWord) return false\n        if (target.closest('.sentence') || target.closest('.phrase')) return false\n        if (target.classList?.contains('flex') && target.querySelector('.phrase')) return false\n        return true\n      }\n\n      const handleFocusRequest = (event: MouseEvent | TouchEvent) => {\n        const target = event.target as HTMLElement | null\n        if (!shouldFocusInput(target)) return\n        window.setTimeout(() => hiddenInput.focus(), 60)\n      }\n\n      const windowListener = (event: KeyboardEvent) => {\n        if (ignoredKeys.has(event.key)) {\n          ignoredKeys.delete(event.key)\n          return\n        }\n        invokeListener(event)\n      }\n\n      hiddenInput.addEventListener('compositionstart', handleCompositionStart)\n      registerCleanup(() => hiddenInput.removeEventListener('compositionstart', handleCompositionStart))\n\n      hiddenInput.addEventListener('compositionend', handleCompositionEnd)\n      registerCleanup(() => hiddenInput.removeEventListener('compositionend', handleCompositionEnd))\n\n      hiddenInput.addEventListener('input', handleInput)\n      registerCleanup(() => hiddenInput.removeEventListener('input', handleInput))\n\n      window.addEventListener('click', handleFocusRequest)\n      registerCleanup(() => window.removeEventListener('click', handleFocusRequest))\n\n      window.addEventListener('touchstart', handleFocusRequest)\n      registerCleanup(() => window.removeEventListener('touchstart', handleFocusRequest))\n\n      window.addEventListener(type, windowListener)\n      registerCleanup(() => window.removeEventListener(type, windowListener))\n\n      registerCleanup(() => {\n        hiddenInput.value = ''\n      })\n    } else {\n      const windowListener = (event: Event) => invokeListener(event as KeyboardEvent)\n      window.addEventListener(type, windowListener)\n      registerCleanup(() => window.removeEventListener(type, windowListener))\n    }\n\n    cleanup = () => {\n      performCleanup()\n      cleanup = null\n    }\n  }\n  onMounted(add)\n  // onActivated(add)\n\n  const remove = () => {\n    if (cleanup) cleanup()\n  }\n\n  onUnmounted(remove)\n  onDeactivated(remove)\n}\n\nexport function getShortcutKey(e: KeyboardEvent) {\n  let shortcutKey = ''\n  if (e.ctrlKey || e.metaKey) shortcutKey += 'Ctrl+'\n  if (e.altKey) shortcutKey += 'Alt+'\n  if (e.shiftKey) shortcutKey += 'Shift+'\n  if (e.key !== 'Control' && e.key !== 'Alt' && e.key !== 'Shift') {\n    if (e.keyCode >= 65 && e.keyCode <= 90) {\n      shortcutKey += e.key.toUpperCase()\n    } else {\n      if (e.key === 'ArrowRight') {\n        shortcutKey += '➡'\n      } else if (e.key === 'ArrowLeft') {\n        shortcutKey += '⬅'\n      } else if (e.key === 'ArrowUp') {\n        shortcutKey += '⬆'\n      } else if (e.key === 'ArrowDown') {\n        shortcutKey += '⬇'\n      } else {\n        shortcutKey += e.key\n      }\n    }\n  }\n  shortcutKey = shortcutKey.trim()\n\n  // console.log('key', shortcutKey)\n  return shortcutKey\n}\n\nexport function useStartKeyboardEventListener() {\n  const runtimeStore = useRuntimeStore()\n  const settingStore = useSettingStore()\n\n  useEventListener('keydown', (e: KeyboardEvent) => {\n    //解决无法复制、全选的问题\n    if ((e.ctrlKey || e.metaKey) && ['KeyC', 'KeyA'].includes(e.code)) return\n    if (!runtimeStore.disableEventListener) {\n      // 检查当前单词是否包含空格，如果包含，则空格键应该被视为输入\n      if (e.code === 'Space') {\n        // 获取当前正在输入的单词信息\n        const currentWord = window.__CURRENT_WORD_INFO__\n\n        // 如果当前单词包含空格，且下一个字符应该是空格，则将空格键视为输入\n        // 或者如果当前处于输入锁定状态（等待空格输入），也将空格键视为输入\n        if (\n          currentWord &&\n          ((currentWord.word && currentWord.word.includes(' ') && currentWord.word[currentWord.input.length] === ' ') ||\n            currentWord.inputLock === true)\n        ) {\n          e.preventDefault()\n          return emitter.emit(EventKey.onTyping, e)\n        }\n      }\n\n      let shortcutKey = getShortcutKey(e)\n      // console.log('shortcutKey', shortcutKey)\n\n      let list = Object.entries(settingStore.shortcutKeyMap)\n      let shortcutEvent = ''\n      for (let i = 0; i < list.length; i++) {\n        let [k, v] = list[i]\n        if (v === shortcutKey) {\n          // console.log('快捷键', k)\n          shortcutEvent = k\n          break\n        }\n      }\n      if (shortcutEvent) {\n        e.preventDefault()\n        emitter.emit(shortcutEvent, e)\n      } else {\n        //非英文模式下，输入区域的 keyCode 均为 229时，\n        // 空格键始终应该被转发到onTyping函数，由它来决定是作为输入还是切换单词\n        if (e.code === 'Space') {\n          e.preventDefault()\n          return emitter.emit(EventKey.onTyping, e)\n        }\n\n        if (\n          ((e.keyCode >= 65 && e.keyCode <= 90) ||\n            (e.keyCode >= 48 && e.keyCode <= 57) ||\n            // 空格键已经在上面处理过了\n            e.code === 'Slash' ||\n            e.code === 'Quote' ||\n            e.code === 'Comma' ||\n            e.code === 'BracketLeft' ||\n            e.code === 'BracketRight' ||\n            e.code === 'Period' ||\n            e.code === 'Minus' ||\n            e.code === 'Equal' ||\n            e.code === 'Semicolon' ||\n            // || e.code === 'Backquote'\n            e.keyCode === 229) &&\n          //当按下功能键时，不阻止事件传播\n          !e.ctrlKey &&\n          !e.altKey\n        ) {\n          if (isMobile() && e.keyCode === 229 && e.key === 'Unidentified') {\n            // 安卓软键盘在keydown阶段不会提供字符，等待input/composition事件来派发实际输入\n            return\n          }\n          e.preventDefault()\n          emitter.emit(EventKey.onTyping, e)\n        } else {\n          emitter.emit(EventKey.keydown, e)\n        }\n      }\n    }\n  })\n  useEventListener('keyup', (e: KeyboardEvent) => {\n    if (!runtimeStore.disableEventListener) {\n      emitter.emit(EventKey.keyup, e)\n    }\n  })\n}\n\nexport function useOnKeyboardEventListener(onKeyDown: (e: KeyboardEvent) => void, onKeyUp: (e: KeyboardEvent) => void) {\n  const add = () => {\n    emitter.on(EventKey.keydown, onKeyDown)\n    emitter.on(EventKey.keyup, onKeyUp)\n  }\n  onMounted(add)\n  // onActivated(add)\n\n  const remove = () => {\n    emitter.off(EventKey.keydown, onKeyDown)\n    emitter.off(EventKey.keyup, onKeyUp)\n  }\n  onUnmounted(remove)\n  onDeactivated(remove)\n}\n\n//因为如果用useStartKeyboardEventListener局部变量控制，当出现多个hooks时就不行了，所以用全局变量来控制\nexport function useDisableEventListener(watchVal: any) {\n  const runtimeStore = useRuntimeStore()\n  watch(watchVal, (n: any) => {\n    runtimeStore.disableEventListener = n\n  })\n}\n"],"names":[],"mappings":";;;AAgQO,SAAS,gCAAgC;AACzB,kBAAA;AACA,kBAAA;AAmFvB;AAmBO,SAAS,wBAAwB,UAAe;AACrD,QAAM,eAAe,gBAAA;AACrB,QAAM,UAAU,CAAC,MAAW;AAC1B,iBAAa,uBAAuB;AAAA,EACtC,CAAC;AACH;"}