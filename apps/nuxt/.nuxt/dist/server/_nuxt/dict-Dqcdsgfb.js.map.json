{"file":"dict-Dqcdsgfb.js","mappings":"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","names":["ignoreList","_ref"],"sources":["../../../../app/hooks/dict.ts"],"sourcesContent":["import type { Article, Dict, TaskWords, Word } from '@/types/types.ts'\nimport { useBaseStore } from '@/stores/base.ts'\nimport { useSettingStore } from '@/stores/setting.ts'\nimport { getDefaultDict, getDefaultWord } from '@/types/func.ts'\nimport { _getDictDataByUrl, cloneDeep, getRandomN, resourceWrap, shuffle, sleep, splitIntoN } from '@/utils'\nimport { onMounted, ref, watch } from 'vue'\nimport { AppEnv, DICT_LIST, DictId } from '@/config/env.ts'\nimport { detail } from '@/apis'\nimport { useRuntimeStore } from '@/stores/runtime.ts'\nimport { useRoute, useRouter } from 'vue-router'\nimport { DictType } from '@/types/enum.ts'\n\nexport function useWordOptions() {\n  const store = useBaseStore()\n\n  function isWordCollect(val: Word) {\n    return !!store.collectWord.words.find(v => v.word.toLowerCase() === val.word.toLowerCase())\n  }\n\n  function toggleWordCollect(val: Word) {\n    let rIndex = store.collectWord.words.findIndex(v => v.word.toLowerCase() === val.word.toLowerCase())\n    if (rIndex > -1) {\n      store.collectWord.words.splice(rIndex, 1)\n    } else {\n      store.collectWord.words.push(val)\n    }\n    store.collectWord.length = store.collectWord.words.length\n  }\n\n  function isWordSimple(val: Word) {\n    return !!store.knownWords.includes(val.word.toLowerCase())\n  }\n\n  function toggleWordSimple(val: Word) {\n    let rIndex = store.knownWords.findIndex(v => v === val.word.toLowerCase())\n    if (rIndex > -1) {\n      store.known.words.splice(rIndex, 1)\n    } else {\n      store.known.words.push(val)\n    }\n    store.known.length = store.known.words.length\n  }\n\n  function delWrongWord(val: Word) {\n    let rIndex = store.wrong.words.findIndex(v => v.word.toLowerCase() === val.word.toLowerCase())\n    if (rIndex > -1) {\n      store.wrong.words.splice(rIndex, 1)\n    }\n    store.wrong.length = store.wrong.words.length\n  }\n\n  function delSimpleWord(val: Word) {\n    let rIndex = store.known.words.findIndex(v => v.word.toLowerCase() === val.word.toLowerCase())\n    if (rIndex > -1) {\n      store.known.words.splice(rIndex, 1)\n    }\n    store.known.length = store.known.words.length\n  }\n\n  return {\n    isWordCollect,\n    toggleWordCollect,\n    isWordSimple,\n    toggleWordSimple,\n    delWrongWord,\n    delSimpleWord,\n  }\n}\n\nexport function useArticleOptions() {\n  const store = useBaseStore()\n\n  function isArticleCollect(val: Article) {\n    return !!store.collectArticle?.articles?.find(v => v.id === val.id)\n  }\n\n  //todo 这里先收藏，再修改。收藏里面的未同步。单词也是一样的\n  function toggleArticleCollect(val: Article) {\n    let rIndex = store.collectArticle.articles.findIndex(v => v.id === val.id)\n    if (rIndex > -1) {\n      store.collectArticle.articles.splice(rIndex, 1)\n    } else {\n      store.collectArticle.articles.push(val)\n    }\n    store.collectArticle.length = store.collectArticle.articles.length\n  }\n\n  return {\n    isArticleCollect,\n    toggleArticleCollect,\n  }\n}\n\nexport function getCurrentStudyWord(): TaskWords {\n  const store = useBaseStore()\n  let data = { new: [], review: [], write: [], shuffle: [] }\n  let dict = store.sdict\n  let isTest = false\n  let words = dict.words.slice()\n  if (isTest) {\n    words = Array.from({ length: 10 }).map((v, i) => {\n      return getDefaultWord({ word: String(i) })\n    })\n  }\n  if (words?.length) {\n    const settingStore = useSettingStore()\n    //忽略时是否加上自定义的简单词\n    let ignoreList = [store.allIgnoreWords, store.knownWords][settingStore.ignoreSimpleWord ? 0 : 1]\n    const perDay = dict.perDayStudyNumber\n    let start = dict.lastLearnIndex\n    let complete = dict.complete\n    let isEnd = start >= dict.length - 1\n    if (isTest) {\n      start = 1\n      complete = true\n    }\n    //如果已完成，并且记录在最后，那么直接随机取复习词\n    if (complete && isEnd) {\n      //复习比最小是1\n      let ratio = settingStore.wordReviewRatio || 1\n      let ignoreList = [store.allIgnoreWords, store.knownWords][settingStore.ignoreSimpleWord ? 0 : 1]\n      // 先将可用词表全部随机，再按需过滤忽略列表，只取到目标数量为止\n      let shuffled = shuffle(cloneDeep(dict.words))\n      let count = 0\n      data.write = []\n      for (let item of shuffled) {\n        if (!ignoreList.includes(item.word.toLowerCase())) {\n          data.write.push(item)\n          count++\n          if (count >= perDay * ratio) {\n            break\n          }\n        }\n      }\n      return data\n    }\n\n    let end = start\n    let list = dict.words.slice(start)\n    //从start往后取perDay个单词，作为当前练习单词\n    for (let item of list) {\n      if (!ignoreList.includes(item.word.toLowerCase())) {\n        if (data.new.length < perDay) {\n          data.new.push(item)\n        } else break\n      }\n      end++\n    }\n\n    //如果复习比大于等于1，或者已完成，那么就取复习词\n    if (settingStore.wordReviewRatio >= 1 || complete) {\n      //从start往前取perDay个单词，作为当前复习单词，取到0为止\n      list = dict.words.slice(0, start).reverse()\n      //但如果已完成，则滚动取值\n      if (complete) list = list.concat(dict.words.slice(end).reverse())\n      for (let item of list) {\n        if (!ignoreList.includes(item.word.toLowerCase())) {\n          if (data.review.length < perDay) {\n            data.review.push(item)\n          } else break\n        }\n        start--\n      }\n    }\n\n    // //如果是自由模式，那么统统设置到new字段里面去\n    // if (settingStore.wordPracticeMode === WordPracticeMode.Free) {\n    //   data.new = data.new.length ? data.new : data.review\n    //   data.review = []\n    //   return data\n    // }\n\n    // 上上次更早的单词\n    //默认只取start之前的单词\n    if (settingStore.wordReviewRatio >= 2) {\n      let candidateWords = dict.words.slice(0, start).reverse()\n      //但如果已完成，则滚动取值\n      if (complete) candidateWords = candidateWords.concat(dict.words.slice(end).reverse())\n      candidateWords = candidateWords.filter(w => !ignoreList.includes(w.word.toLowerCase()))\n      // console.log(candidateWords.map(v => v.word))\n      //最终要获取的单词数量\n      const totalNeed = perDay * (settingStore.wordReviewRatio - 1)\n      if (candidateWords.length <= totalNeed) {\n        data.write = candidateWords\n      } else {\n        //write数组放的是上上次之前的单词，总的数量为perDayStudyNumber * 3，取单词的规则为：从后往前取6个perDayStudyNumber的，越靠前的取的单词越多。\n        let days = 6\n        // 分6组，每组最多 perDay 个\n        const groups: Word[][] = splitIntoN(candidateWords.slice(0, days * perDay), 6)\n        // console.log('groups', groups)\n\n        // 分配数量，靠前组多，靠后组少，例如分配比例 [6,5,4,3,2,1]\n        const ratio = Array.from({ length: days }, (_, i) => i + 1).reverse()\n        const ratioSum = ratio.reduce((a, b) => a + b, 0)\n        const realRatio = ratio.map(r => Math.round((r / ratioSum) * totalNeed))\n        // console.log(ratio, ratioSum, realRatio, realRatio.reduce((a, b) => a + b, 0))\n\n        // 按比例从每组随机取单词\n        let writeWords: Word[] = []\n        groups.map((v, i) => {\n          writeWords = writeWords.concat(getRandomN(v, realRatio[i]))\n        })\n        // console.log('writeWords', writeWords)\n        data.write = writeWords\n      }\n    }\n\n    //如果已完成，那么合并写词和复习词\n    if (complete) {\n      // data.new = []\n      // data.review = data.review.concat(data.write)\n      // data.write = []\n    }\n  }\n  // console.log('data-new', data.new.map(v => v.word))\n  // console.log('data-review', data.review.map(v => v.word))\n  // console.log('data-write', data.write.map(v => v.word))\n  return data\n}\n\nexport function useGetDict() {\n  const store = useBaseStore()\n  const runtimeStore = useRuntimeStore()\n  let waiting = $ref(false)\n  let fetching = $ref(false)\n  const route = useRoute()\n  const router = useRouter()\n\n  watch(\n    [() => store.load, () => waiting],\n    ([a, b]) => {\n      if (a && b) {\n        loadDict()\n      }\n    },\n    { immediate: true }\n  )\n\n  onMounted(() => {\n    // console.log('onMounted')\n    if (route.query?.isAdd) {\n      runtimeStore.editDict = getDefaultDict()\n    } else {\n      if (!runtimeStore.editDict?.id) {\n        let dictId = route.params?.id\n        if (!dictId) {\n          return router.push('/articles')\n        }\n        waiting = true\n      } else {\n        loadDict(runtimeStore.editDict)\n      }\n    }\n  })\n\n  async function loadDict(dict?: Dict) {\n    if (!dict) {\n      dict = getDefaultDict()\n      let dictId = route.params.id\n      //先在自己的词典列表里面找，如果没有再在资源列表里面找\n      dict = store.article.bookList.find(v => v.id === dictId)\n      let r = await fetch(resourceWrap(DICT_LIST.ARTICLE.ALL))\n      let dict_list = await r.json()\n      if (!dict) dict = dict_list.flat().find(v => v.id === dictId) as Dict\n    }\n    if (dict && dict.id) {\n      if (\n        !dict?.articles?.length &&\n        !dict?.custom &&\n        ![DictId.articleCollect].includes(dict.en_name || dict.id) &&\n        !dict?.is_default\n      ) {\n        fetching = true\n        let r = await _getDictDataByUrl(dict, DictType.article)\n        runtimeStore.editDict = r\n      }\n      if (store.article.bookList.find(book => book.id === runtimeStore.editDict.id)) {\n        if (AppEnv.CAN_REQUEST) {\n          let res = await detail({ id: runtimeStore.editDict.id })\n          if (res.success) {\n            runtimeStore.editDict.statistics = res.data.statistics\n            if (res.data.articles.length) {\n              runtimeStore.editDict.articles = res.data.articles\n            }\n          }\n        }\n      }\n    } else {\n      router.push('/articles')\n    }\n\n    waiting = false\n    fetching = false\n  }\n\n  const loading = computed(() => waiting || fetching)\n\n  return { loading }\n}\n"],"version":3}