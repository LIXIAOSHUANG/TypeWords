import{u as R,t as G,c as ee,i as te,a as N,b as oe}from"./Bqmt5lv0.js";import{z as Q,D as X,bk as Y,H as d,j as ne,l as ae}from"./Dbiv707D.js";const U=te?window:void 0,re={json:"application/json",text:"text/plain"};function Z(r){return r&&ee(r,"immediate","refetch","initialData","timeout","beforeFetch","afterFetch","onFetchError","fetch","updateDataOnError")}function W(r){return typeof Headers<"u"&&r instanceof Headers?Object.fromEntries(r.entries()):r}function se(r,...s){var O,g;const z=typeof AbortController=="function";let T={},n={immediate:!0,refetch:!1,timeout:0,updateDataOnError:!1};const o={method:"GET",type:"text",payload:void 0};s.length>0&&(Z(s[0])?n={...n,...s[0]}:T=s[0]),s.length>1&&Z(s[1])&&(n={...n,...s[1]});const{fetch:I=(O=U?.fetch)!==null&&O!==void 0?O:(g=globalThis)===null||g===void 0?void 0:g.fetch,initialData:J,timeout:V}=n,_=N(),q=N(),K=N(),D=d(!1),y=d(!1),x=d(!1),j=d(null),C=d(null),P=d(null),w=d(J||null),$=ne(()=>z&&y.value);let p,v;const A=e=>{z&&(p?.abort(e),p=new AbortController,p.signal.onabort=()=>x.value=!0,T={...T,signal:p.signal})},H=e=>{y.value=e,D.value=!e};V&&(v=R(A,V,{immediate:!1}));let k=0;const h=async(e=!1)=>{var a;A(),H(!0),P.value=null,j.value=null,x.value=!1,k+=1;const b=k,l={method:o.method,headers:{}},i=X(o.payload);if(i){var S;const t=W(l.headers),F=Object.getPrototypeOf(i);!o.payloadType&&i&&(F===Object.prototype||Array.isArray(F))&&!(i instanceof FormData)&&(o.payloadType="json"),o.payloadType&&(t["Content-Type"]=(S=re[o.payloadType])!==null&&S!==void 0?S:o.payloadType),l.body=o.payloadType==="json"?JSON.stringify(i):i}let M=!1;const c={url:X(r),options:{...l,...T},cancel:()=>{M=!0}};if(n.beforeFetch&&Object.assign(c,await n.beforeFetch(c)),M||!I)return H(!1),Promise.resolve(null);let f=null;return v&&v.start(),I(c.url,{...l,...c.options,headers:{...W(l.headers),...W((a=c.options)===null||a===void 0?void 0:a.headers)}}).then(async t=>{if(C.value=t,j.value=t.status,f=await t.clone()[o.type](),!t.ok)throw w.value=J||null,new Error(t.statusText);return n.afterFetch&&({data:f}=await n.afterFetch({data:f,response:t,context:c,execute:h})),w.value=f,_.trigger(t),t}).catch(async t=>{let F=t.message||t.name;if(n.onFetchError&&({error:F,data:f}=await n.onFetchError({data:f,error:t,response:C.value,context:c,execute:h})),P.value=F,n.updateDataOnError&&(w.value=f),q.trigger(t),e)throw t;return null}).finally(()=>{b===k&&H(!1),v&&v.stop(),K.trigger(null)})},L=G(n.refetch);Q([L,G(r)],([e])=>e&&h(),{deep:!0});const E={isFinished:Y(D),isFetching:Y(y),statusCode:j,response:C,error:P,data:w,canAbort:$,aborted:x,abort:A,execute:h,onFetchResponse:_.on,onFetchError:q.on,onFetchFinally:K.on,get:u("GET"),put:u("PUT"),post:u("POST"),delete:u("DELETE"),patch:u("PATCH"),head:u("HEAD"),options:u("OPTIONS"),json:m("json"),text:m("text"),blob:m("blob"),arrayBuffer:m("arrayBuffer"),formData:m("formData")};function u(e){return(a,b)=>{if(!y.value)return o.method=e,o.payload=a,o.payloadType=b,ae(o.payload)&&Q([L,G(o.payload)],([l])=>l&&h(),{deep:!0}),{...E,then(l,i){return B().then(l,i)}}}}function B(){return new Promise((e,a)=>{oe(D).toBe(!0).then(()=>e(E)).catch(a)})}function m(e){return()=>{if(!y.value)return o.type=e,{...E,then(a,b){return B().then(a,b)}}}}return n.immediate&&Promise.resolve().then(()=>h()),{...E,then(e,a){return B().then(e,a)}}}export{se as u};
